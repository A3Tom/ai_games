# Phase 06 — Ticket 002: Incoming Message Dispatch

## Summary

Add the incoming message handler to `useRelay` that parses raw WebSocket messages, routes relay system messages (`peer_count`, `peer_left`, `error`) to `useConnectionStore`, and forwards game messages to the `onGameMessage` callback. After this ticket, two browser clients connected to the same room can exchange typed game messages, and peer presence is tracked in the store.

## Prerequisites

- **Ticket 001** must be complete — `app/src/composables/useRelay.ts` exists with WebSocket connection lifecycle, `connected` ref, and `send()`.
- `app/src/utils/validation.ts` must exist (Phase 3) — exports `parseIncomingMessage()`, `isPeerCountMessage()`, `isPeerLeftMessage()`, `isRelayErrorMessage()`.
- `app/src/stores/connection.ts` must exist (Phase 4) — exports `useConnectionStore` with `setPeerConnected(value: boolean)` action.

## Scope

**In scope:**

- WebSocket `onmessage` handler in `useRelay`
- Parse raw message data with `parseIncomingMessage()` from `utils/validation.ts`
- Handle `peer_count` messages: call `store.setPeerConnected(count >= 2)`
- Handle `peer_left` messages: call `store.setPeerConnected(false)`
- Handle `error` messages: log with `console.warn`
- Forward all `GameMessage` types to the `onGameMessage` callback from options
- Drop and log invalid/unparseable messages
- Unit tests for all message routing paths

**Out of scope:**

- Game message interpretation (shots, results, commits, etc.) — Phase 8 (`useGameProtocol`)
- Exponential backoff reconnection — ticket 003
- Ping/pong latency handling — ticket 004
- UI for connection status — Phase 13

## Files

| File | Action | Description |
|------|--------|-------------|
| `app/src/composables/useRelay.ts` | Modify | Add `onmessage` handler with message parsing and dispatch |
| `app/src/composables/useRelay.test.ts` | Modify | Add tests for message dispatch logic |

## Requirements

### Message Handler

Wire the `onmessage` handler on the WebSocket instance inside `useRelay`. The handler must:

1. Extract the raw string from `event.data` (type `string`).
2. Call `parseIncomingMessage(raw)` from `../utils/validation`.
3. If `parseIncomingMessage` returns `null`, log `console.warn('Received invalid message:', raw)` and return.
4. Determine message category and dispatch:

#### Relay Messages (handled internally)

These messages are generated by the relay server and are NOT forwarded to the `onGameMessage` callback.

**`peer_count`** — Use `isPeerCountMessage()` type guard:
- If `message.count >= 2`, call `store.setPeerConnected(true)`.
- If `message.count < 2`, call `store.setPeerConnected(false)`.

**`peer_left`** — Use `isPeerLeftMessage()` type guard:
- Call `store.setPeerConnected(false)`.

**`error`** — Use `isRelayErrorMessage()` type guard:
- Log `console.warn('Relay error:', message.code, message.message)`.
- Do NOT call `onGameMessage`. Do NOT throw.

#### Game Messages (forwarded to callback)

All messages that are not relay system messages (i.e., they are part of the `GameMessage` union type) are forwarded to `options.onGameMessage(message)`.

The type narrowing logic: after parsing with `parseIncomingMessage()`, if the message is not a `PeerCountMessage`, `PeerLeftMessage`, or `RelayErrorMessage`, it must be a `GameMessage` (per the `IncomingMessage = GameMessage | RelayMessage` union). Forward it to the callback.

### Imports to Add

```typescript
import { parseIncomingMessage } from '../utils/validation'
import {
  isPeerCountMessage,
  isPeerLeftMessage,
  isRelayErrorMessage,
} from '../utils/validation'
```

### Discriminating Relay vs Game Messages

Use the type guards from `validation.ts` to identify relay messages. The dispatch logic should be:

```
if (isPeerCountMessage(parsed)) → handle peer_count
else if (isPeerLeftMessage(parsed)) → handle peer_left
else if (isRelayErrorMessage(parsed)) → handle error
else → call onGameMessage(parsed as GameMessage)
```

The `as GameMessage` cast is safe because `parseIncomingMessage` only returns `IncomingMessage | null`, and `IncomingMessage = GameMessage | RelayMessage`. After excluding all `RelayMessage` variants, the remainder is `GameMessage`. See `docs/05-PROTOCOL-SPEC.md` Section 2 for the full message taxonomy.

### Error Handling

Per `docs/03-CODING-STANDARDS.md` Section 6:

- Never silently swallow errors — log at minimum.
- Protocol errors (invalid messages, unexpected types): log and ignore, don't crash.
- The `onGameMessage` callback may throw. Wrap the callback invocation in a try/catch and log any errors: `console.error('Error in onGameMessage handler:', error)`. This prevents a bug in Phase 8's handler from crashing the WebSocket message loop.

### Test Requirements

Extend the existing test file. Use the `MockWebSocket` from ticket 001 with a `simulateMessage(data: string)` helper:

```typescript
simulateMessage(data: string): void {
  if (this.onmessage) {
    this.onmessage({ data } as MessageEvent)
  }
}
```

Required test cases (minimum):

1. **peer_count with count 2 sets peer connected:** Simulate `{ type: "peer_count", count: 2 }` message. Assert `store.setPeerConnected(true)` called.
2. **peer_count with count 1 sets peer disconnected:** Simulate `{ type: "peer_count", count: 1 }` message. Assert `store.setPeerConnected(false)` called.
3. **peer_left sets peer disconnected:** Simulate `{ type: "peer_left" }` message. Assert `store.setPeerConnected(false)` called.
4. **Relay error is logged:** Simulate `{ type: "error", code: "ROOM_FULL", message: "Room is full" }`. Assert `console.warn` called. Assert `onGameMessage` NOT called.
5. **Game message forwarded to callback:** Simulate `{ type: "ready" }` message. Assert `onGameMessage` called with `{ type: 'ready' }`.
6. **Shot message forwarded to callback:** Simulate `{ type: "shot", x: 3, y: 7 }`. Assert `onGameMessage` called with the parsed shot message.
7. **Invalid JSON dropped:** Simulate `"not json"`. Assert `console.warn` called. Assert `onGameMessage` NOT called. Assert no error thrown.
8. **Unknown message type dropped:** Simulate `{ type: "unknown_type" }`. Assert `console.warn` called (`parseIncomingMessage` returns `null`). Assert `onGameMessage` NOT called.
9. **Callback error caught:** Set `onGameMessage` to throw an error. Simulate a valid game message. Assert `console.error` called. Assert composable does not crash.

## Acceptance Criteria

- [ ] `useRelay` `onmessage` handler parses incoming messages with `parseIncomingMessage()`
- [ ] `peer_count` with `count >= 2` calls `store.setPeerConnected(true)`
- [ ] `peer_left` calls `store.setPeerConnected(false)`
- [ ] Game messages (e.g., `{ type: "ready" }`) forwarded to `onGameMessage` callback
- [ ] Invalid messages logged and dropped without crashing
- [ ] `npm run type-check` passes with no errors
- [ ] All tests pass via `npm run test`

## Notes for the Agent

- **Do NOT interpret game messages.** The `useRelay` composable is a transport layer. It passes game messages to the callback verbatim. It does not check turns, validate shots against the board, or update `useGameStore`. That's Phase 8's job. See `docs/phases/phase-06-connection-composable.md` Section 8, Boundaries.
- **Use the existing type guards from `validation.ts`.** Do not rewrite type guard logic. Import `isPeerCountMessage`, `isPeerLeftMessage`, `isRelayErrorMessage` directly. These have already been implemented and tested in Phase 3.
- **The `parseIncomingMessage` function handles JSON parsing.** You do not need to call `JSON.parse` yourself in the message handler. `parseIncomingMessage` takes a raw string, parses it, and validates it. If it returns `null`, the message is invalid.
- **Wrap `onGameMessage` in try/catch.** A bug in the downstream handler should not break the WebSocket message loop. Log the error and continue.
- **Do not filter game message types.** Forward ALL parsed messages that are not relay messages. The `GameMessage` union includes `ready`, `commit`, `shot`, `result`, `reveal`, `rematch`, `ping`, `pong`, `sync_request`, and `sync_response`. Do not hardcode a list — use the relay message exclusion pattern.
- **The `simulateMessage` helper** should be added to the `MockWebSocket` class if it doesn't already exist from ticket 001. It calls the `onmessage` handler with a minimal `MessageEvent`-like object.
- Reference `docs/05-PROTOCOL-SPEC.md` Section 7 for the message validation pattern and Section 2 for the full message taxonomy.
