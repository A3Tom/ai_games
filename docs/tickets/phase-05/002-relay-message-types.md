# Phase 05 — Ticket 002: Relay Message Types

## Summary

Define the relay-side TypeScript type definitions in `relay/src/types.ts`. These types cover the three categories of messages the relay handles: messages consumed by the relay (`join`), messages generated by the relay (`peer_count`, `peer_left`, `error`), and the type guard for parsing incoming join messages. When done, the agent should have a fully typed relay message system that compiles cleanly.

## Prerequisites

- **Ticket 001** must be complete — `relay/package.json` and `relay/tsconfig.json` must exist with TypeScript installed.

## Scope

**In scope:**

- `JoinMessage` interface — consumed by relay, not forwarded
- `PeerCountMessage` interface — generated by relay
- `PeerLeftMessage` interface — generated by relay
- `RelayErrorMessage` interface — generated by relay
- `RelayOutgoingMessage` union type
- `RelayErrorCode` const object for error codes
- Type guard `isJoinMessage()` for parsing incoming messages
- `RelayConfig` interface for server configuration

**Out of scope:**

- Game message types (`shot`, `result`, `commit`, etc.) — the relay does not inspect these. They are defined in `app/src/types/protocol.ts` (Phase 2) and are irrelevant to the relay.
- `Room` interface — ticket 003 (defined in `room-manager.ts` where it is used)
- `HealthResponse` interface — ticket 004 (defined in `health.ts` where it is used)
- Any implementation code — this ticket is types only

## Files

| File | Action | Description |
|------|--------|-------------|
| `relay/src/types.ts` | Create | All relay-side message type definitions |

## Requirements

All types must follow the discriminated union pattern per `docs/03-CODING-STANDARDS.md` Section 1.2 — every message has a `type` literal discriminant. No `enum` keyword; use `as const` objects where needed per `docs/03-CODING-STANDARDS.md` Section 1.1.

### Interfaces

From `docs/phases/phase-05-relay-server.md` Section 6:

```typescript
/** Messages consumed by the relay (not forwarded) */
export interface JoinMessage {
  type: 'join'
  roomId: string
}

/** Sent to all clients in a room when the peer count changes */
export interface PeerCountMessage {
  type: 'peer_count'
  count: number
}

/** Sent to remaining client when the other peer disconnects */
export interface PeerLeftMessage {
  type: 'peer_left'
}

/** Sent to a client when the relay rejects an action */
export interface RelayErrorMessage {
  type: 'error'
  code: 'ROOM_FULL' | 'INVALID_MESSAGE' | 'RATE_LIMITED'
  message: string
}
```

### Union Type

```typescript
export type RelayOutgoingMessage = PeerCountMessage | PeerLeftMessage | RelayErrorMessage
```

### Error Code Constant

Use an `as const` object instead of `enum` (per `docs/03-CODING-STANDARDS.md` Section 1.1):

```typescript
export const RELAY_ERROR_CODE = {
  ROOM_FULL: 'ROOM_FULL',
  INVALID_MESSAGE: 'INVALID_MESSAGE',
  RATE_LIMITED: 'RATE_LIMITED',
} as const

export type RelayErrorCode = typeof RELAY_ERROR_CODE[keyof typeof RELAY_ERROR_CODE]
```

### Configuration Interface

```typescript
export interface RelayConfig {
  port: number
  maxRooms: number
  maxClientsPerRoom: number
  roomTimeoutMs: number
  logLevel: string
}
```

This is used by `server.ts` (ticket 005) to read environment variables into a typed config object. The fields map directly to the environment variables in `.env.example` (ticket 001).

### Type Guard

```typescript
export function isJoinMessage(data: unknown): data is JoinMessage {
  return (
    typeof data === 'object' &&
    data !== null &&
    'type' in data &&
    (data as Record<string, unknown>).type === 'join' &&
    'roomId' in data &&
    typeof (data as Record<string, unknown>).roomId === 'string' &&
    (data as Record<string, unknown>).roomId.length > 0
  )
}
```

The type guard must validate:
- `data` is a non-null object
- `data.type` is exactly `'join'`
- `data.roomId` is a non-empty string

This follows the message validation pattern from `docs/05-PROTOCOL-SPEC.md` Section 8.

## Acceptance Criteria

- [ ] File exists at `relay/src/types.ts`
- [ ] All 4 message interfaces are exported: `JoinMessage`, `PeerCountMessage`, `PeerLeftMessage`, `RelayErrorMessage`
- [ ] `RelayOutgoingMessage` union type is exported
- [ ] `RELAY_ERROR_CODE` const object is exported (no `enum` keyword used)
- [ ] `RelayConfig` interface is exported with all 5 fields
- [ ] `isJoinMessage` type guard is exported and correctly narrows `unknown` to `JoinMessage`
- [ ] `npm run build` in `relay/` produces no TypeScript errors (creates `dist/types.js`)

## Notes for the Agent

- **No `enum` keyword.** Use `as const` objects per `docs/03-CODING-STANDARDS.md` Section 1.1. This is a project-wide rule.
- **No `any` type.** The type guard parameter must be `unknown`, not `any`. Narrow using type checks per `docs/03-CODING-STANDARDS.md` Section 1.1.
- **Export everything.** All interfaces, types, constants, and the type guard must be exported. Other relay files import from this module.
- **Do not define game message types** (shot, result, commit, reveal, etc.). The relay forwards these verbatim without inspecting them. Only relay-specific types belong here.
- **The `Room` interface does NOT go in this file.** It's defined in `room-manager.ts` (ticket 003) because it's an implementation detail of the room manager, not a message type.
- **Keep `isJoinMessage` strict.** The relay uses this to determine if an incoming message is a join request. All other messages are forwarded to the room. A false positive would incorrectly consume a game message.
