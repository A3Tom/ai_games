# Protocol Specification: Sea Strike

## 1. Transport

- **Protocol:** WebSocket (RFC 6455)
- **Encoding:** UTF-8 JSON
- **Relay endpoint:** `wss://relay.yourdomain.com`
- **Max message size:** 4 KB (relay should reject larger messages)

All client-to-client messages are sent as JSON over a single WebSocket connection to the relay, which forwards them to the other client(s) in the same room.

---

## 2. Connection Lifecycle

### 2.1 Client → Relay (Control Messages)

These messages are consumed by the relay and not forwarded.

```typescript
// Join a room
{ "type": "join", "roomId": "a1b2c3d4" }
```

### 2.2 Relay → Client (System Messages)

These messages are generated by the relay. Clients must handle them.

```typescript
// Number of peers in the room changed
{ "type": "peer_count", "count": 2 }

// The other peer disconnected
{ "type": "peer_left" }

// Error from relay (room full, invalid message, etc.)
{ "type": "error", "code": "ROOM_FULL" | "INVALID_MESSAGE" | "RATE_LIMITED", "message": "Human-readable detail" }
```

### 2.3 Client → Relay → Client (Game Messages)

All other messages are forwarded verbatim by the relay to the other client(s) in the room. The relay does not inspect, validate, or modify these messages.

---

## 3. Room Management

### 3.1 Room ID Format

- Generated by the creating client using `nanoid` with a custom alphabet: `0123456789abcdefghijklmnopqrstuvwxyz`.
- Length: 8 characters.
- Example: `k7m2x9pq`
- The room ID is embedded in the URL: `https://<user>.github.io/<repo>/#/game/k7m2x9pq`

### 3.2 Room Rules

| Rule | Value |
|------|-------|
| Max clients per room | 2 |
| Room timeout (no activity) | 1 hour |
| Room creation | Implicit on first `join` message for a room ID |
| Room deletion | When both clients disconnect, or on timeout |

### 3.3 Join Behavior

| Scenario | Relay Response |
|----------|---------------|
| First client joins room | `{ "type": "peer_count", "count": 1 }` |
| Second client joins room | Both receive `{ "type": "peer_count", "count": 2 }` |
| Third client joins room | `{ "type": "error", "code": "ROOM_FULL", "message": "Room is full" }` then disconnect |
| Client reconnects to room with 1 peer | `{ "type": "peer_count", "count": 2 }` to both |

---

## 4. Game Message Types

### 4.1 Full Type Definitions

```typescript
// === Ship Types ===
type ShipType = 'carrier' | 'battleship' | 'cruiser' | 'submarine' | 'destroyer'

// === Setup Phase ===
interface ReadyMessage {
  type: 'ready'
}

interface CommitMessage {
  type: 'commit'
  hash: string  // 64-char hex SHA-256
}

// === Battle Phase ===
interface ShotMessage {
  type: 'shot'
  x: number  // 0-9
  y: number  // 0-9
}

interface ResultMessage {
  type: 'result'
  x: number  // 0-9, echoes the shot coordinates
  y: number  // 0-9
  hit: boolean
  sunk: ShipType | null  // non-null if this shot sunk a ship
}

// === Reveal Phase ===
interface ShipPlacement {
  type: ShipType
  x: number         // origin column, 0-9
  y: number         // origin row, 0-9
  orientation: 'h' | 'v'
}

interface RevealMessage {
  type: 'reveal'
  ships: ShipPlacement[]  // exactly 5 ships, sorted alphabetically by type
  salt: string            // 64-char hex encoding of the 32-byte salt
}

// === Meta ===
interface RematchMessage {
  type: 'rematch'
}

interface PingMessage {
  type: 'ping'
  timestamp: number  // Date.now()
}

interface PongMessage {
  type: 'pong'
  timestamp: number  // echoed from ping
}

interface SyncRequestMessage {
  type: 'sync_request'
}

interface SyncResponseMessage {
  type: 'sync_response'
  phase: GamePhase
  turnNumber: number
  shotHistory: Array<{
    x: number
    y: number
    hit: boolean
    sunk: ShipType | null
    player: 'a' | 'b'
  }>
}

// === Union ===
type GameMessage =
  | ReadyMessage
  | CommitMessage
  | ShotMessage
  | ResultMessage
  | RevealMessage
  | RematchMessage
  | PingMessage
  | PongMessage
  | SyncRequestMessage
  | SyncResponseMessage
```

---

## 5. Game Phase Transitions

```
            ┌──────────┐
            │  LOBBY   │  Both clients connected
            └────┬─────┘
                 │ peer_count === 2
                 ▼
            ┌──────────┐
            │  SETUP   │  Both placing ships
            └────┬─────┘
                 │ Both send "ready"
                 ▼
            ┌──────────┐
            │  COMMIT  │  Exchange board hashes
            └────┬─────┘
                 │ Both send "commit" and receive opponent's commit
                 ▼
            ┌──────────┐
            │  BATTLE  │  Alternating shots
            └────┬─────┘
                 │ All ships of one player sunk
                 ▼
            ┌──────────┐
            │  REVEAL  │  Exchange boards + salts, verify
            └────┬─────┘
                 │ Verification complete
                 ▼
            ┌──────────┐
            │ GAMEOVER │  Show results, offer rematch
            └────┬─────┘
                 │ Both send "rematch"
                 ▼
            ┌──────────┐
            │  SETUP   │  (new game, same room)
            └──────────┘
```

### 5.1 Phase Rules

| Phase | Allowed Outgoing Messages | Expected Incoming Messages |
|-------|--------------------------|---------------------------|
| LOBBY | (none) | `peer_count` from relay |
| SETUP | `ready` | `ready` from opponent |
| COMMIT | `commit` | `commit` from opponent |
| BATTLE | `shot` (on your turn), `result` (on opponent's turn) | `shot` (on opponent's turn), `result` (on your turn) |
| REVEAL | `reveal` | `reveal` from opponent |
| GAMEOVER | `rematch` | `rematch` from opponent |

Any message received outside its valid phase should be logged and ignored.

---

## 6. Turn Management

- **Player A** (room creator) always goes first.
- The creating client is determined by who sends the first `join` message for a room ID. The relay can indicate this by including `"isHost": true` in the `peer_count` response (only on the first join, not on reconnect).
- Alternatively, both clients can derive turn order from a deterministic rule: the client with the lexicographically smaller commit hash goes first. This removes the need for relay involvement in role assignment.
- Turns alternate strictly. A client must not send a `shot` unless it has received a `result` for its previous shot.

### 6.1 Turn Validation (Client-Side)

```
State: awaitingResult = false

On my turn:
  1. User clicks cell (x, y) on opponent board
  2. Validate: awaitingResult === false
  3. Validate: cell (x, y) has not been shot before
  4. Send { type: "shot", x, y }
  5. Set awaitingResult = true

On receiving result:
  1. Validate: awaitingResult === true
  2. Validate: result.x, result.y matches last sent shot
  3. Update opponent board
  4. Set awaitingResult = false
  5. It is now the opponent's turn
```

---

## 7. Board Commitment Protocol

### 7.1 Commitment

```
Input:
  ships: ShipPlacement[]  — sorted alphabetically by ship.type
  salt: Uint8Array(32)    — from crypto.getRandomValues

Process:
  1. canonical = JSON.stringify(ships)  // deterministic because array is sorted
  2. saltHex = Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('')
  3. payload = canonical + ':' + saltHex
  4. hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(payload))
  5. hash = Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('')

Output:
  hash: string  — 64-character lowercase hex
```

### 7.2 Verification

```
Input:
  opponentHash: string           — received during COMMIT phase
  opponentShips: ShipPlacement[] — received during REVEAL phase
  opponentSalt: string           — received during REVEAL phase (64-char hex)

Process:
  1. canonical = JSON.stringify(opponentShips)
  2. payload = canonical + ':' + opponentSalt
  3. recomputedHash = SHA-256(payload)  // same as above
  4. valid = (recomputedHash === opponentHash)

Output:
  valid: boolean
```

### 7.3 Post-Game Result Verification

After the board is verified against the commitment, also verify that all shot results were honest:

```
For each shot in shotHistory where the opponent was defending:
  1. Look up the cell (x, y) on the opponent's revealed board
  2. Check: if the opponent reported "hit", the cell should contain a ship
  3. Check: if the opponent reported "miss", the cell should be empty
  4. Check: if the opponent reported "sunk: <type>", all cells of that ship should be hit

If any check fails → cheatDetected = true
```

---

## 8. Message Validation

Every incoming message must be validated before processing. Use type guard functions:

```typescript
function isShotMessage(msg: unknown): msg is ShotMessage {
  return (
    typeof msg === 'object' &&
    msg !== null &&
    'type' in msg &&
    msg.type === 'shot' &&
    'x' in msg &&
    'y' in msg &&
    typeof msg.x === 'number' &&
    typeof msg.y === 'number' &&
    msg.x >= 0 && msg.x <= 9 &&
    msg.y >= 0 && msg.y <= 9 &&
    Number.isInteger(msg.x) &&
    Number.isInteger(msg.y)
  )
}
```

Provide a type guard for every message type. Invalid messages should be logged and dropped — never crash the game.

---

## 9. Reconnection Protocol

### 9.1 Client Reconnection

```
1. WebSocket closes unexpectedly
2. Client sets connectionStore.status = 'reconnecting'
3. Exponential backoff: wait 1s, 2s, 4s, 8s, 16s, 30s (cap), 30s, ...
4. Attempt new WebSocket connection
5. On success:
   a. Send { type: "join", roomId: <same room> }
   b. Wait for peer_count
   c. If peer is present, send { type: "sync_request" }
   d. Peer responds with { type: "sync_response", ... }
   e. Reconcile state and resume
6. On max retries (10):
   a. Set connectionStore.status = 'disconnected'
   b. Show manual retry button
```

### 9.2 State Reconciliation

On receiving a `sync_response`, the reconnecting client:

1. Compares `sync_response.turnNumber` with its own turn counter.
2. If they match, resume normally.
3. If they differ, apply any missing shots from `sync_response.shotHistory` to update local state.
4. The phase from `sync_response` takes precedence if the reconnecting client is behind.

---

## 10. Rate Limiting

### 10.1 Relay-Side

- Max 30 WebSocket connections per IP per minute (enforced by Caddy or relay).
- Max 60 messages per client per minute (enforced by relay).
- Messages exceeding 4 KB are rejected with `{ "type": "error", "code": "INVALID_MESSAGE" }`.

### 10.2 Client-Side

- Debounce shot clicks: 200ms minimum between shots.
- Do not send duplicate shots (same coordinates).
- Do not send messages outside valid phases.
